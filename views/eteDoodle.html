<!DOCTYPE html>
<html>
<head>
<title>ETE Doodle</title>

<link rel="stylesheet" href="http://code.jquery.com/ui/1.10.2/themes/smoothness/jquery-ui.css"/>
<link rel="stylesheet" href="css/doodle.css"/>

<script type="text/javascript" src="js/jquery-1.9.1.js"></script>
<script type="text/javascript" src="js/jquery-ui-1.10.2.js"></script>
<script type="text/javascript" src="js/leap.min.js"></script>

<script type="text/javascript">

window.URL = window.URL || window.webkitURL;
navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia ||
        navigator.mozGetUserMedia || navigator.msGetUserMedia;

var MAX_LEAP_X = 140;
var MIN_LEAP_X = -140;
var MIN_LEAP_Y = 25;
var MAX_LEAP_Y = 260;
var LEAP_HEIGHT = (MAX_LEAP_Y - MIN_LEAP_Y);
var HALF_SCREEN_WIDTH = window.innerWidth / 2;
var FULL_SCREEN_HEIGHT = window.innerHeight;
var Y_SCALE_FACTOR = 1.2;
var xData = [0, 0];
var yData = [0, 0];

var lastPointableId = null;
var lastScreenX = 0;
var lastScreenY = 0;
var lastScreenTapTime = 0;

var hoverStartMs = 0;
var hoverStartX = 0;
var hoverStartY = 0;
var lastElementHoverClicked = null;
var lastElementHoverTime = 0;

var enteredCanvas = false;
var fingerBrushDown = false;

// Z intervals: 0,25,50,75,100
var zDepthLineWidthArray = [1,3,5,7,9];

var uploadCanvasImage = function (canvas) {
    // Base64 encoded string of the image data
    var imageDataBase64 = canvas.toDataURL('image/png');

    // TODO: This call will be moved to when the user clicks "Save" after doodling on image
    $.post('/eteDoodle/saveSnapshot', {imageData: imageDataBase64}, function (data) {
        console.log("Image uploaded successfully.");
    });
};

var takeSnapshotFromVideo = function (video, stream, canvas, canvasContext) {
    canvasContext.drawImage(video, 0, 0, video.width, video.height);
    var imageData = canvasContext.getImageData(0, 0, video.width, video.height);

    // Stop the webcam
    video.pause();
    video.src = '';
    stream.stop();

    return imageData;
};

var startWebcamVideo = function (video, webStreamCallback) {

    var onVideoCaptureError = function (error) {
        console.log("Video capture error: " + error.code);
        webStreamCallback(null);
    }

    if (navigator.getUserMedia) {
        navigator.getUserMedia({video: true}, function (stream) {
            video.src = window.URL.createObjectURL(stream);
            video.play();

            if (webStreamCallback) {
                webStreamCallback(stream);
            }
        }, onVideoCaptureError);
    }
};

var leapToScreenX = function (leapX) {
    return Math.round((((leapX / MAX_LEAP_X)) + 1) * HALF_SCREEN_WIDTH);
};

var leapToScreenY = function (leapY) {
    var screenY = 0;
    if (leapY >= MIN_LEAP_Y && leapY <= MAX_LEAP_Y) {
        screenY = Math.round(Y_SCALE_FACTOR * FULL_SCREEN_HEIGHT * (1 - ((leapY - MIN_LEAP_Y) / LEAP_HEIGHT)));
    }
    return screenY;
};


var leapFrameHandler = function (frame, debugModeOn) {
    if (debugModeOn) {
        console.log("Frame event");
        // If only a finger is showing, number of hands can be zero
        console.log("# of fingers = " + frame.pointables.length);
    }
    // Tip position is in millimeters from the Leap origin
    var changed = false;
    var screenTapDetected = false;
    var screenX, screenY = 0;
    var xPosFromOriginMm, yPosFromOriginMm, zPosFromOriginMm = 0;
    var tipVelocity = null;
    if (frame.gestures && frame.gestures.length == 1) {
        // Only process screen tap
        if (frame.gestures[0].type === 'screenTap') {
            screenTapDetected = true;
            xPosFromOriginMm = frame.gestures[0].position[0];
            yPosFromOriginMm = frame.gestures[0].position[1];
            screenX = leapToScreenX(xPosFromOriginMm);
            screenY = leapToScreenY(yPosFromOriginMm);
        }
        else if (frame.gestures[0].type === 'swipe') {
            //console.log("Swipe detected going " + frame.gestures[0].direction);
        }
        else if (frame.gestures[0].type === 'circle') {
            //console.log("Circle detected: Radius = " + frame.gestures[0].radius);
            //console.log("Circle detected: Progress = " + frame.gestures[0].progress);
        }
    }
    else if (frame.pointables.length >= 1) {
        var trackedPointable = null;
        if (!lastPointableId) {
            trackedPointable = frame.pointables[0];
        }
        else {
            for (var i = 0; i < frame.pointables.length; i++) {
                if (frame.pointables[i].id == lastPointableId) {
                    trackedPointable = frame.pointables[i];
                    break;
                }
            }
            if (null == trackedPointable) {
                console.log("New pointable");
                trackedPointable = frame.pointables[0];
            }
        }
        lastPointableId = trackedPointable.id;

        //console.log("Finger position = " + frame.pointables[i].toString());
        xPosFromOriginMm = trackedPointable.tipPosition[0];
        yPosFromOriginMm = trackedPointable.tipPosition[1];
        zPosFromOriginMm = trackedPointable.tipPosition[2];
        tipVelocity = trackedPointable.tipVelocity;

        if (debugModeOn) {
            if (xPosFromOriginMm > xData[1]) {
                xData[1] = xPosFromOriginMm;
                changed = true;
            }
            else if (xPosFromOriginMm < xData[0]) {
                xData[0] = xPosFromOriginMm;
                changed = true;
            }
            if (yPosFromOriginMm > yData[1]) {
                yData[1] = yPosFromOriginMm;
                changed = true;
            }
            else if (yPosFromOriginMm < yData[0]) {
                yData[0] = yPosFromOriginMm;
                changed = true;
            }
        }
        // Is there a better way to calibrate the leap ??
        screenX = leapToScreenX(xPosFromOriginMm);
        screenY = leapToScreenY(yPosFromOriginMm);
    }
    /*if (frame.hands.length > 0) {
     if (frame.hands[0].fingers) {
     if (debugModeOn) {
     console.log("Number of fingers w/hand = " + frame.hands[0].fingers.length);
     }
     }
     }*/

    return [screenX, screenY, xData, yData, changed, xPosFromOriginMm, yPosFromOriginMm, zPosFromOriginMm, screenTapDetected, frame.pointables.length, tipVelocity];
};

$(document).ready(function () {
    var $video = $('#videoCapture');
    var video = $video[0];
    var $canvas = $('#doodleCanvas')
    var canvas = $canvas[0];
    var canvasCtx = canvas.getContext('2d');
    var webCamStream = null;
    var origSnapshotImageData = null;
    var canvasOffset = $canvas.offset();
    var canvasOffsetLeft = canvasOffset.left;
    var canvasOffsetRight = canvasOffsetLeft + canvas.width;
    var canvasOffsetTop = canvasOffset.top;
    var canvasOffsetBottom = canvasOffsetTop + canvas.height;
    var currentColor = 'rgb(0, 0, 0, 0)';
    var brushDown = false;
    var debugModeOn = false;
    var $currPos = $('#currPos');
    var $leapCursor = $('#leapCursor');
    var $posDataArea = $('#posDataArea');

    var drawBegin = function (cursorX, cursorY) {
        canvasCtx.strokeStyle = currentColor;
        canvasCtx.lineWidth = 1;
        canvasCtx.beginPath();
        canvasCtx.moveTo((cursorX - canvasOffsetLeft), (cursorY - canvasOffsetTop));
    };

    var drawEnd = function () {
        canvasCtx.stroke();
    };

    var drawAndUpdatePosition = function (cursorX, cursorY, lineWidth) {
        var canvasX = (cursorX - canvasOffsetLeft);
        var canvasY = (cursorY - canvasOffsetTop);

        if (lineWidth) {
            canvasCtx.lineWidth = lineWidth;
        }

        canvasCtx.lineTo(canvasX, canvasY);
        canvasCtx.stroke();

        // Now start a new path from this point
        canvasCtx.beginPath();
        canvasCtx.moveTo(canvasX, canvasY);
    };

    var paintBrushDown = function (cursorX, cursorY) {
        brushDown = true;
        drawBegin(cursorX, cursorY);
    };

    var paintBrushUp = function () {
        brushDown = false;
        drawEnd();
    };

    var paintBrushStroke = function (cursorX, cursorY, lineWidth) {
        if (brushDown) {
            drawAndUpdatePosition(cursorX, cursorY, lineWidth);
        }
    };

    canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

    $(document).delegate('.paintColor', 'click', function (event) {
        currentColor = $(this).css('background-color');
        console.log("Clicked color = " + currentColor);
    });

    $('#resetImageButton').bind('click', function (event) {
        if (origSnapshotImageData) {
            canvasCtx.putImageData(origSnapshotImageData, 0, 0);
        }
    });

    $('#saveImageButton').bind('click', function (event) {
        uploadCanvasImage(canvas);
    });

    $canvas.mouseenter(function (event) {
        console.log("Entered canvas");
    });

    $canvas.mouseleave(function (event) {
        console.log("Left canvas");
        // If mouse button is still pressed, finish drawing
        if (brushDown) {
            drawEnd();
            brushDown = false;
        }
    });

    $canvas.mousedown(function (event) {
        console.log("Mouse down in canvas");
        paintBrushDown(event.pageX, event.pageY);
    });

    $canvas.mouseup(function (event) {
        console.log("Mouse up in canvas");
        paintBrushUp();
    });

    $canvas.mousemove(function (event) {
        paintBrushStroke(event.pageX, event.pageY);
    });

    $(document).keydown(function (event) {
        if (event.keyCode === 68) {
            debugModeOn = !debugModeOn;
            console.log("Debug mode off!");
        }
    });

    $('#photoSnapshotDialog').dialog({
        resizable: false,
        modal: true,
        minWidth: 1050,
        minHeight: 794,
        buttons: {
            "takeSnapshotButton": {
                text: "Take photo",
                id: "takeSnapshotButton",
                click: function () {
                    origSnapshotImageData = takeSnapshotFromVideo(video, webCamStream, canvas, canvasCtx);
                    $(this).dialog('close');
                    var controller = new Leap.Controller({enableGestures: true});
                    controller.on('animationFrame', function (frame) {
                        var posData = leapFrameHandler(frame, debugModeOn);

                        if (posData[0] !== lastScreenX) {
                            $leapCursor.css('left', posData[0]);
                        }
                        if (posData[1] !== lastScreenY) {
                            $leapCursor.css('top', posData[1]);
                        }

                        // Are we in the canvas?
                        if (posData[0] >= canvasOffsetLeft && posData[0] <= canvasOffsetRight
                            && posData[1] >= canvasOffsetTop && posData[1] <= canvasOffsetBottom) {
                            //$posDataArea.html("<li>Z Pos = " + posData[7] + ", X = " + posData[0] + ", Y = " + posData[1] + ", Fingers = " + posData[9] + "</li>");
                            var fingerBrushCurrentlyDown = posData[7] < 0;
                            if (!enteredCanvas) {
                                enteredCanvas = true;
                            }
                            if (!fingerBrushDown) {
                                // Entering drawing surface first time
                                if (fingerBrushCurrentlyDown) {
                                    console.log("Entered drawing surface");
                                    fingerBrushDown = true;
                                    paintBrushDown(posData[0], posData[1]);
                                }
                            }
                            else {
                                // Was on drawing surface previously
                                // If still on drawing surface, continue drawing
                                if (posData[10][2] > 100) {
                                    console.log("Z Velocity Threshold Passed");
                                }
                                if (fingerBrushCurrentlyDown && posData[10][2] <= 100) {
                                    var index = Math.min(Math.floor(Math.abs(posData[7]) / 25), 4);
                                    var lineWidth = zDepthLineWidthArray[index];
                                    $posDataArea.html("<li>Z Pos = " + posData[7] + ", X = " + posData[0] + ", Y = " + posData[1] + ", Fingers = " + posData[9] + "</li>");
                                    paintBrushStroke(posData[0], posData[1], lineWidth);
                                }
                                else {
                                    // Picked up paint brush
                                    console.log("Left drawing surface");
                                    paintBrushUp();
                                    fingerBrushDown = false;
                                }
                            }
                        }
                        else {
                            if (enteredCanvas) {
                                // Leaving canvas
                                enteredCanvas = false;

                                if (fingerBrushDown) {
                                    console.log("Leaving canvas while drawing - leave drawing surface");
                                    paintBrushUp();
                                    fingerBrushDown = false;
                                }
                            }

                            // Hover click processing
                            if (posData[9] > 0) {
                                if (hoverStartMs > 0) {
                                    if (Math.abs(hoverStartX - posData[0]) <= 10 ||
                                            Math.abs(hoverStartY - posData[1]) <= 10) {
                                        var hoverTime = Date.now();
                                        if ((hoverTime - hoverStartMs) >= 1000) {
                                            // We've hovered over a point for a while, get the element
                                            // and see if its leapHoverClickable

                                            console.log("Hover click detected!");

                                            $(leapCursor).hide();
                                            var hoverElement = document.elementFromPoint(hoverStartX, hoverStartY);
                                            $(leapCursor).show();

                                            if (lastElementHoverClicked == hoverElement && ((hoverTime - lastElementHoverTime) <= 1000)) {
                                                // Do not process hover click events on the same element within 1 second
                                            }
                                            else {
                                                console.log("Hover Start Pos = " + '(' + hoverStartX + ', ' + hoverStartY + ')');
                                                console.log("Hover Element Clicked = " + $(hoverElement).attr('id'));

                                                $(hoverElement).trigger('click');
                                                lastElementHoverClicked = hoverElement;
                                                lastElementHoverTime = hoverTime;
                                            }

                                            hoverStartMs = 0;
                                            hoverStartX = 0;
                                            hoverStartY = 0;
                                        }
                                    }
                                    else {
                                        hoverStartMs = 0;
                                        hoverStartX = 0;
                                        hoverStartY = 0;
                                    }
                                }
                                else {
                                    if (Math.abs(lastScreenX - posData[0]) <= 10 ||
                                            Math.abs(lastScreenY - posData[1]) <= 10) {
                                        // Only start hover detecting if the velocity in X and Y is under 10mm/s
                                        if (posData[10]
                                                && Math.abs(posData[10][0]) <= 10
                                                && Math.abs(posData[10][1]) <= 10) {
                                            hoverStartMs = Date.now();
                                            hoverStartX = posData[0];
                                            hoverStartY = posData[1];

                                            $(leapCursor).hide();
                                            var hoverElement = document.elementFromPoint(hoverStartX, hoverStartY);
                                            $(leapCursor).show();


                                            if (!$(hoverElement).hasClass('leapHoverClickable')
                                                    || (lastElementHoverClicked == hoverElement && ((hoverStartMs - lastElementHoverTime) <= 5000))) {
                                                // Do not process hover click events on the same element within 5 seconds
                                                hoverStartMs = 0;
                                                hoverStartX = 0;
                                                hoverStartY = 0;
                                            }
                                        }
                                    }
                                }
                            }


                            // Gesture processing
                            if (posData[8] === true) {
                                // Screen tap detected - only accept it if previous tap is at least a second apart
                                var screenTapTime = Date.now();
                                if ((screenTapTime - lastScreenTapTime) >= 1000) {
                                    console.log("Screen tap detected!!");
                                    $(leapCursor).hide();
                                    var element = document.elementFromPoint(posData[0], posData[1]);
                                    console.log("Element = " + $(element).attr('id'));
                                    if (element) {
                                        $(element).trigger('click');
                                        $(element).css('color', 'red');
                                    }
                                    $(leapCursor).show();
                                    lastScreenTapTime = screenTapTime;
                                }
                            }
                        }

                        // Update last screen position
                        lastScreenX = posData[0];
                        lastScreenY = posData[1];

                        if (debugModeOn) {
                            $currPos.html('(' + posData[0] + ', ' + posData[1] + ')' + '&lt;- (' + posData[5] + ', ' + posData[6] + ')');
                            if (posData[4] === true) {
                                $posDataArea.html('<li>Max X:' + posData[2][1] + '</li><li>Min X:' + posData[2][0] + '</li>');
                                $posDataArea.append('<li>Max Y:' + posData[3][1] + '</li><li>Min Y:' + posData[3][0] + '</li>');
                            }
                        }
                    });
                    controller.connect();
                }
            }
        }
    });

    $('#takeSnapshotButton').attr('disabled', 'disabled');
    startWebcamVideo(video, function (stream) {
        webCamStream = stream;
        $('#takeSnapshotButton').removeAttr('disabled');
    });
});
</script>
</head>
<body>
<div id="doodleApp" style="width: 100%; height: 100%">
    <canvas id="doodleCanvas" width="1024" height="768" style="border: solid 2px;"></canvas>
    <div id="toolPane" class="toolPane">
        <ul class="paintColorList">
            <li id="redPen" class="paintColor backgroundRed leapHoverClickable"></li>
            <li id="greenPen" class="paintColor backgroundGreen leapHoverClickable"></li>
            <li id="bluePen" class="paintColor backgroundBlue leapHoverClickable"></li>
            <li id="yellowPen" class="paintColor backgroundYellow leapHoverClickable"></li>
        </ul>
        <ul class="actionButtonList" style="text-align: left;">
            <li>
                <button id="drawButton" type="button" class="actionButton leapHoverClickable">START DRAWING</button>
            </li>
            <li>
                <button id="resetImageButton" type="button" class="actionButton leapHoverClickable">START OVER</button>
            </li>
            <li>
                <button id="saveImageButton" type="button" class="actionButton leapHoverClickable">SAVE IT!!</button>
            </li>
        </ul>
        <div id="leapDebugInfo">
            <div id="currPos"></div>
            <ul id="posDataArea" style="font-size:14pt;">
            </ul>
        </div>

    </div>
</div>
<div id="leapCursor" style="top:0;left:0;width:10px;height:10px;background-color:greenyellow;position:absolute;">
</div>
<div id="photoSnapshotDialog" title="Smile!" style="width:1050px; height:794px;display:none;">
    <video id="videoCapture" width="1024" height="768" autoplay></video>
</div>

</body>
</html>